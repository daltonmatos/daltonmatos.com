:title: Calling modern C code (avr-gcc) from legacy Assembly (avrasm2)
:author: Dalton Barreto
:date: 2015-07-26
:status: published
:lang: en
:translation: true
:slug: chamando-codigo-novo-em-c-avr-gcc-a-partir-de-um-codigo-assembly-legado-avrasm2
:url: blog/en/chamando-codigo-novo-em-c-avr-gcc-a-partir-de-um-codigo-assembly-legado-avrasm2
:save_as: blog/en/chamando-codigo-novo-em-c-avr-gcc-a-partir-de-um-codigo-assembly-legado-avrasm2/index.html

This post is part of a `series of posts <{filename}chamando-codigo-assembly-legado-avrasm2-a-partir-de-um-codigo-novo-em-c-avr-gcc.rst>`_ about mixing C (``avr-gcc``) code with Assembly (``avrasm2``). If you didn't read the previous articles, it's strongly suggested that you read them before continue.

Context
=======

A very important part of a mixed code project, in this case C with Assembly, is the ability to freely call code of both languages. We must have a way to call an Assembly routine from the C code and to call a C function from an Assembly code. Until now, in this series of posts, we did only the first option. In this post we will se how to call a C function from the Assembly code.

Understanding an External symbol
================================

Every routine the code needs to call is transformed into a symbol that will be used by the link-editor, when generating the final binary. We saw this `in the post about the symbol table <{filename}convertendo-ihex-para-elf-preservando-as-labels-originais-como-simbolos.rst>`_, when ``avr-gcc`` took care of this for us as we were dealing with an external symbol of the C code. This time we will have an external symbol of the Assembly code and that's why we will need to add this symbol manually to the symbol table.

The right way to declare an external symbol of the C code is this:

.. code-block:: c

  extern void asm_main();

Looking at the symbol table generated by ``avr-gcc``, we have:

.. code-block:: objdump

  Section Headers:
  [  Nr ] Type              Addr     Size     ES Flg Lk Inf Al Name
  [    0] NULL              00000000 00000000 00     00 000 00                   
  [    1] PROGBITS          00000000 00000000 00 AX  00 000 01 .text             
  [    2] PROGBITS          00000000 00000000 00 WA  00 000 01 .data             
  [    3] NOBITS            00000000 00000000 00 WA  00 000 01 .bss              
  [    4] PROGBITS          00000000 0000003e 00 AX  00 000 01 .text.startup     
  [    5] RELA              00000000 00000078 0c     08 004 04 .rela.text.startup 
  [    6] PROGBITS          00000000 00000028 01     00 000 01 .comment          
  [    7] STRTAB            00000000 00000048 00     00 000 01 .shstrtab         
  [    8] SYMTAB            00000000 000000e0 10     09 00c 04 .symtab           
  [    9] STRTAB            00000000 0000004a 00     00 000 01 .strtab           
  Key to Flags: W (write), A (alloc), X (execute)


  Symbol table (.symtab)
  [  Nr ] Value    Size     Type    Bind      Sect Name
  [    0] 00000000 00000000 NOTYPE  LOCAL        0   
  [    1] 00000000 00000000 FILE    LOCAL    65521 main.c 
  [    2] 00000000 00000000 SECTION LOCAL        1   
  [    3] 00000000 00000000 SECTION LOCAL        2   
  [    4] 00000000 00000000 SECTION LOCAL        3   
  [    5] 0000003e 00000000 NOTYPE  LOCAL    65521 __SP_H__ 
  [    6] 0000003d 00000000 NOTYPE  LOCAL    65521 __SP_L__ 
  [    7] 0000003f 00000000 NOTYPE  LOCAL    65521 __SREG__ 
  [    8] 00000000 00000000 NOTYPE  LOCAL    65521 __tmp_reg__ 
  [    9] 00000001 00000000 NOTYPE  LOCAL    65521 __zero_reg__ 
  [   10] 00000000 00000000 SECTION LOCAL        4   
  [   11] 00000000 00000000 SECTION LOCAL        6   
  [   12] 00000000 0000003e FUNC    GLOBAL       4 main 
  [   13] 00000000 00000000 NOTYPE  GLOBAL       0 asm_main 

This output was generated with ELFIO [#]_. It brings and example code named ``elfdump``.

Looking at the table, we see that the symbol ``asm_main`` belongs to a special section named ``NULL``. We know this by looking at the ``Sect`` column, which in this case has the value of ``0``. In the first table, the ``Section Headers:``, the section with index ``0`` is exactly the ``NULL`` section. What we need to do is add our external symbols belonging to this section and hope that avr-gcc will undestand and that the link-edition works when we generate our final binary. Let's see.

Dealing with the absense of symbols in the Intel Hex file format
================================================================

The ``extern`` instruction, that we use when programming with ``avr-gcc``, simply does no exist when we are writting Assembly code and compiling with ``avrasm2``, that's because ``avrasm2`` only generates one Intel Hex at the end and does not have a link-edition phase during compilation. It gets even more complex since in our case the Assembly code is compiled completely separated from the C code and thus does not "know" that one (or more) of its symbols, in fact, are implemeted in C.

Let's see an example of Assembly code that will have an external symbol.

.. code-block:: asm

  .org 0x0000

  other_routine:
    ret

  ; This funcions is just a stub. Its implementation will be in C
  call_me_maybe:
    nop

  internal_to_asm:
    ret

  asm_main:
    call internal_to_asm
    call call_me_maybe
    ret


In this code, the ``call_me_maybe`` routine will have its implementation in C. The problem is that it **must exist** in the Assembly code during compilation, otherwise ``avrasm2`` won't be able to compile the code and generate the Intel Hex output. So what we need to do is compile the code as usual, but we can remove all the code from the external routine, or even put its label in any part of the code. For now we will leave its code with a simple ``nop`` instruction.

We do the normal compilation and `conversion (Intel Hex to avr-elf32) <{filename}convertendo-ihex-para-elf-preservando-as-labels-originais-como-simbolos.rst>`_, what is different now is that we need to reconstruct the symbol table with two types of symbols: Internal and External. In this case the only external symbol will be ``call_me_maybe``.


We will use the exact same tools we did in the `last post <{filename}convertendo-ihex-para-elf-preservando-as-labels-originais-como-simbolos.rst>`_, just with a few code modification to support this new types of symbols: Internal and External. To make it easier I put the name of the External symbol directly inside the code of the ``extract-symbols-metadata.py`` [#]_ tool. The output format of this tool had to be changed as well, because now we have two types of symbols. The format of the output is this:

.. code-block:: text

  <symbol_name> <symbol_type> <symbol_address> <instruction_addresses>

Now we have a new field to know if the symbol will be Internal or External (``<symbol_type>`` field). This way, when we pass this output as input to our second tool, ``elf-add-symbol`` [#]_, it can correctly add the external symbols, that is, the ones that must belong to the ``NULL`` section we saw previously in this post.

At this stage we compile the as code as usual. Looking ate the symbol table, after the conversion from Intel Hex to ``avr-elf32``, we have the following:

.. code-block:: objdump

  Section Headers:
  [  Nr ] Type              Addr     Size     ES Flg Lk Inf Al Name
  [    0] NULL              00000000 00000000 00     00 000 00                   
  [    1] PROGBITS          00000000 00000010 00 AX  00 000 01 .text             
  [    2] STRTAB            00000000 0000002b 00     00 000 01 .shstrtab         
  [    3] SYMTAB            00000000 00000060 10     04 002 04 .symtab           
  [    4] STRTAB            00000000 00000036 00     00 000 01 .strtab           
  [    5] REL               00000000 00000010 08     03 001 04 .rel.text         
  Key to Flags: W (write), A (alloc), X (execute)


  Symbol table (.symtab)
  [  Nr ] Value    Size     Type    Bind      Sect Name
  [    0] 00000000 00000000 NOTYPE  LOCAL        0   
  [    1] 00000000 00000000 SECTION LOCAL        1   
  [    2] 00000000 00000000 NOTYPE  GLOBAL       1 other_routine
  [    3] 00000006 00000000 NOTYPE  GLOBAL       1 asm_main 
  [    4] 00000000 00000000 NOTYPE  GLOBAL       0 call_me_maybe 
  [    5] 00000004 00000000 NOTYPE  GLOBAL       1 internal_to_asm 


Note that now the ``call_me_maybe`` symbol correcly belong to the ``NULL`` section. Let's see the disassembly of this code before finally linking:
  
.. code-block:: objdump


  Disassembly of section .text:

  00000000 <other_routine>:
     0:   08 95           ret
          ...

  00000004 <internal_to_asm>:
     4:   08 95           ret

  00000006 <asm_main>:
     6:   0e 94 02 00     call    0x4     ; 0x4 <internal_to_asm>
     a:   0e 94 01 00     call    0x2     ; 0x2 <other_routine+0x2>
     e:   08 95           ret

Looking at the instruction at address ``0xa``, which is the line of code that calls the ``call_me_maybe`` routine, we see that the call is being made to a totally wrong address (``0x2``). But looking at the relocation table we see that this instruction will be edited by the compiler when linking to other codes. Also note that this disassembly does not even shows the original ``call_me_maybe`` symbol. That's because it is now an external symbol.

.. code-block:: objdump

  RELOCATION RECORDS FOR [.text]:
  OFFSET   TYPE              VALUE 
  0000000a R_AVR_CALL        call_me_maybe
  00000006 R_AVR_CALL        internal_to_asm

What this table is showing is that when ``avr-gcc`` starts the linking process it will know that these 2 instructions will have to be edited and will jump to the final address of the symbols ``call_me_maybe`` and ``internal_to_asm``, respectively. Now let's see the C code and how it shows up on the disassembly.

This is the code we will use in our example:

.. code-block:: c

  #include <avr/io.h>

  static int a = 1;


  void call_me_maybe(){
    a += 1;
    if (a > 3){
      return;
    }
    return;
  }

  extern void asm_main();

  int main(){
    
    asm_main();
      
    DDRB = DDRB | _BV(PB5); // PIN13 (internal led) as output
    PORTB = PORTB | _BV(PB5); // HIGH
    
    return 0;
  }

Looking at the symbol table, we have:

.. code-block:: objdump

  Section Headers:
  [  Nr ] Type              Addr     Size     ES Flg Lk Inf Al Name
  [    0] NULL              00000000 00000000 00     00 000 00                   
  [    1] PROGBITS          00000000 00000014 00 AX  00 000 01 .text       <-----      
  [    2] RELA              00000000 00000030 0c     09 001 04 .rela.text        
  [    3] PROGBITS          00000000 00000002 00 WA  00 000 01 .data             
  [    4] NOBITS            00000000 00000000 00 WA  00 000 01 .bss              
  [    5] PROGBITS          00000000 0000000e 00 AX  00 000 01 .text.startup     
  [    6] RELA              00000000 0000000c 0c     09 005 04 .rela.text.startup 
  [    7] PROGBITS          00000000 00000028 01     00 000 01 .comment          
  [    8] STRTAB            00000000 0000004d 00     00 000 01 .shstrtab         
  [    9] SYMTAB            00000000 00000110 10     0a 00d 04 .symtab           
  [   10] STRTAB            00000000 00000069 00     00 000 01 .strtab           
  Key to Flags: W (write), A (alloc), X (execute)


  Symbol table (.symtab)
  [  Nr ] Value    Size     Type    Bind      Sect Name
  [    0] 00000000 00000000 NOTYPE  LOCAL        0   
  [    1] 00000000 00000000 FILE    LOCAL    65521 main.c 
  [    2] 00000000 00000000 SECTION LOCAL        1   
  [    3] 00000000 00000000 SECTION LOCAL        3   
  [    4] 00000000 00000000 SECTION LOCAL        4   
  [    5] 0000003e 00000000 NOTYPE  LOCAL    65521 __SP_H__ 
  [    6] 0000003d 00000000 NOTYPE  LOCAL    65521 __SP_L__ 
  [    7] 0000003f 00000000 NOTYPE  LOCAL    65521 __SREG__ 
  [    8] 00000000 00000000 NOTYPE  LOCAL    65521 __tmp_reg__ 
  [    9] 00000001 00000000 NOTYPE  LOCAL    65521 __zero_reg__ 
  [   10] 00000000 00000002 OBJECT  LOCAL        3 a 
  [   11] 00000000 00000000 SECTION LOCAL        5   
  [   12] 00000000 00000000 SECTION LOCAL        7   
  [   13] 00000000 00000014 FUNC    GLOBAL       1 call_me_maybe     <-----
  [   14] 00000000 0000000e FUNC    GLOBAL       5 main 
  [   15] 00000000 00000000 NOTYPE  GLOBAL       0 asm_main 
  [   16] 00000000 00000000 NOTYPE  GLOBAL       0 __do_copy_data 

We can see that the ``call_me_maybe`` symbol belongs to the ``.text`` section, this is correct as this is an internal symbol to this C code.

Important to note that this code itself also has external symbols, as an example the ``asm_main`` symbol. This is due to the fact that the "main()" is being done in C and as we want to test the Assembly->C calling we need a way to make our C code call an Assembly routine, and that's done when we call ``asm_main()``. In this post we end up testing both calling directions: C->Assembly and Assembly->C.

Joining all parts and producing the final binary
================================================


Now that we have both ``avr-elf32`` prepared and with their symbol and relocation tables created, we need to ask the compiler to join both binaries into an final output that we will be able to flash into the micro-controller memory.

This step, the link-edition (together with compiling), is done as usual with ``avr-gcc``, with a command line like this:

.. code-block:: shell

  avr-gcc -mmcu=atmega328p -F_CPU=100000 -o final_elf.elf main.c elf_from_asm_code.elf

Where ``main.c`` is our C code and ``elf_from_asm_code.elf`` is our Assembly code that was compiled by ``avrasm2``, converted to ``avr-elf32`` and had its symbol and relocation tables reconstructed. Joining these two binaries we have in the end ``final_elf.elf``, already with all symbol references resolved and instructions edited by the compiler.

Let's see how the final disassembly is:

.. code-block:: objdump

  00000096 <call_me_maybe>:
    96:   80 91 00 01     lds     r24, 0x0100
    9a:   90 91 01 01     lds     r25, 0x0101
    9e:   01 96           adiw    r24, 0x01       ; 1
    a0:   90 93 01 01     sts     0x0101, r25
    a4:   80 93 00 01     sts     0x0100, r24
    a8:   08 95           ret

  000000aa <_other_routines>:
    aa:   00 00           nop
          ...

  000000ae <internal_to_asm>:
    ae:   08 95           ret

  000000b0 <asm_main>:
    b0:   0e 94 57 00     call    0xae    ; 0xae <internal_to_asm>
    b4:   0e 94 4b 00     call    0x96    ; 0x96 <call_me_maybe>
    b8:   08 95           ret

  000000ba <main>:
    ba:   0e 94 58 00     call    0xb0    ; 0xb0 <asm_main>
    be:   25 9a           sbi     0x04, 5 ; 4
    c0:   2d 9a           sbi     0x05, 5 ; 5
    c2:   80 e0           ldi     r24, 0x00       ; 0
    c4:   90 e0           ldi     r25, 0x00       ; 0
    c6:   08 95           ret



We can note here that the code of the ``call_me_maybe`` routine (which was positioned at adress ``0x00000096``) is, in fact, the code that is in the ``main.c`` and not the simple ``nop`` that we left in the original Assembly code. That is, we were able to overwrite a Assembly routine with a C implemented one.

It is also important to note that the final addresses are all corect. The compiler fixed all instructions that pointed do the ``call_me_maybe`` symbol. Remember the ``call 0x2`` that we had in the Assembly that we convertd to ``avr-elf32``? It was corectly fixed and now points to ``0x96`` (look at the instruction at address ``0xb4``) which happends to be ``call_me_maybe``'s final address!

Now what we have to do is flash this binary into the micro-controller memory. And the best of all is that is actually works!!


.. [#] `ElfIO - C++ library for reading and generating ELF files <http://elfio.sourceforge.net/>`_
.. [#] `extract-symbols-metadata <{filename}/extra/extract-symbols-metadata-v2.py>`_
.. [#] `CÃ³digo-fonte da ferramenta elf-add-symbol <{filename}/extra/elf-add-symbol-v2.cpp>`_
