:title: Calling legacy Assembly code (AVRASM2) from modern C code (avr-gcc)
:author: Dalton Barreto
:date: 2015-04-12
:lang: en
:translation: true
:tags: avr, microcontrollers, avr-C, avr-assembly
:slug: chamando-codigo-assembly-legado-avrasm2-a-partir-de-um-codigo-novo-em-c-avr-gcc
:status: published
:url: blog/en/chamando-codigo-assembly-legado-avrasm2-a-partir-de-um-codigo-novo-em-c-avr-gcc
:save_as: blog/en/chamando-codigo-assembly-legado-avrasm2-a-partir-de-um-codigo-novo-em-c-avr-gcc/index.html

Context
=======

Every tutorial I found online about mixing C and Assembly code show how to do it in the same way, using ``avr-gcc``. The problem with this technique is that it assumes you are starting a new project. This means that the Assembly code must be in a syntax expected by ``avr-as`` (GNU Assembler). When I say "legacy code" I refer to code made with AVR Studio, using ``AVRASM2`` as the assembler. The ``AVRASM2`` syntax is incompatible with ``avr-as`` syntax, so you can't simply take the code and compile with ``avr-as``.

Depending on the size of you project it's not feasible do migrate all at once and that's where it becomes useful to mix C and Assembly, because you can write C code at the same time the system is evolving and eventualy gaining new features. The challenge of this post is to join two projects that were made using different tools (``avr-gcc`` and ``AVR Studio``) that are, at first, incompatible with each other.

The majority of these legacy projects (all of them?) were made with assemblers that did not expect to be mixed with C, therefore produces binaries that do not support linking and other necessary features so we can join these two languages. This is the case of ``AVR Studio`` (when using ``AVRASM2`` as the assembler) it generates in the end a Inter Hex [#]_ file, which doest not support, amongst other things, linking.

Preparing the files
===================

Before we begin we need to have all files in the same format, so we can use ``avr-gcc`` to generate the final binary, which means that we need to convert all our files to a format that ``avr-gcc`` understands.

Since ``AVRASM2`` generates Intel Hex we need to convert this to ``elf32-avr`` (ELF), this way we will be able to join them using ``avr-gcc``. There isn't a direct conversion between HEX and ELF, what we can do is convert from HEX to flat binary and then to ELF. The conversion is done with ``avr-objcopy``.

An AVRASM2 example
==================

Let's take this example of a simple code made with ``AVRASM2`` so we can illustrate the complete process.

.. code-block:: asm
  
      .include "m328Pdef.inc"

      .org 0x0000

      _blinks:
        ldi r23, 0xa
        add r24, r23
        clr r1
        clr r25
        ret 

This code just adds 10 to the parameter received. The ``.include`` line is needed because it brings all register/memory definitions for the micro controller we are using. In this case we are using a ATmega328P, but you can use any other AVR. Important to note is the ``.org 0x0000`` instruction, this tells the compiler to put our code at address ``0``. We will need this later.

The HEX file generated by ``AVRASM2`` (AVR Studio, for example) has only one section named ``.sec1``, so we need to copy only this section to the flat binary.

.. code-block:: objdump

      $ avr-objdump -h blinks.hex

      blinks.hex:     file format ihex

      Sections:
      Idx Name          Size      VMA       LMA       File off  Algn
        0 .sec1         0000000a  00000000  00000000  00000011  2**0
                        CONTENTS, ALLOC, LOAD


Copying this section to the flat ginary:

.. code-block:: shell-session

      $ avr-objcopy -j .sec1 -I ihex -O binary blinks.hex blinks.bin


Now we need to convert it to ELF:

.. code-block:: shell-session

      $ avr-objcopy  --rename-section .data=.progmem.data,contents,alloc,load,readonly,data \
      -I binary -O elf32-avr blinks.bin blinks.elf

At this stage we already have a binary that we can link to our code generated by ``avr-gcc``. But we still have some problems. 
Looking closer to the ELF we see that the symbol ``_blinks`` is not present in the symbol table and we need to know where our routine begins so we can reference it in the C code.

.. code-block:: objdump

  $ avr-objdump -x blink_simple.asm.elf

  blink_simple.asm.elf:     file format elf32-avr

  SYMBOL TABLE:
  00000000 l    d  .progmem.data	00000000 .progmem.data
  00000000 g       .progmem.data	00000000 _binary_blinks_bin_start
  0000000a g       .progmem.data	00000000 _binary_blinks_bin_end
  0000000a g       *ABS*	        00000000 _binary_blinks_bin_size


The three ``_binary_*`` symbols were added by ``avr-objcopy`` and mean, respectivelly, the start, end and size of our code after compiled. Even with he absence of the ``_blinks`` symbol we can infer where it is. If we go back to our assembly code we will see the ``.org 0x0000`` instruction and we know that it forces our code to be located at address ``0``. So we can use the ``_binary_blinks_bin_start`` as being our entry point to the assembly code.


Looking at the C code
=====================

To validate our hypothesis, let's do a C code that calls this routine written in Assembly. The code is very simple, all it does is flash the LED that is on the D13 pin. Because we are testing this code in an Arduino Nano, the D13 port is actually bit 5 of PORTB [#]_.

.. code-block:: c

  #include <avr/io.h>
  #include <util/delay.h>

  // Arduino Pin13 is mapped to PORTB, bit 5
  // See: http://www.arduino.cc/en/Reference/PortManipulation

  extern char ASM_SYM(char n);

  int main(void){

    uint8_t total_blinks =  ASM_SYM(5);
    DDRB = DDRB | _BV(PB5); // PIN13 (internal led) as output

    PORTB = PORTB | _BV(PB5); // HIGH
    for (;;){
      uint8_t i;
      for (i = 0; i < total_blinks; i++){
        PORTB = PORTB | _BV(PB5); // HIGH
        _delay_ms(200);

        PORTB &= ~_BV(PB5); // LOW
          _delay_ms(200);
      }
      _delay_ms(1000);
    }

    return 0;
  }

        
As we will be using this same code to link with several different assembly codes, we will leave the function name as a constant (``ASM_SYM``) and we will pass a value for this constant to ``avr-gcc`` when compiling this code.

Compilling all the code and linking the final binary
====================================================

The compilation of the C code is very simple and is similtar to any other:

.. code-block:: shell-session

  $ avr-gcc -mmcu=atmega328p -Os -DF_CPU=16000000 -DASM_SYM=_binary_blinks_bin_start -o main.elf main.c blinks.elf


We can look at the ELF to see if the code seems correct:

.. code-block:: shell-session

  $ avr-objdump -d main.elf


.. code-block:: objdump


  Disassembly of section .text:

  00000000 <__vectors>:
     0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
     4:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>

  00000068 <__ctors_end>:
    68:	11 24       	eor	r1, r1
    6a:	1f be       	out	0x3f, r1	; 63
    6c:	cf ef       	ldi	r28, 0xFF	; 255
    6e:	d8 e0       	ldi	r29, 0x08	; 8
    70:	de bf       	out	0x3e, r29	; 62
    72:	cd bf       	out	0x3d, r28	; 61
    74:	0e 94 45 00 	call	0x8a	; 0x8a <main>
    78:	0c 94 6d 00 	jmp	0xda	; 0xda <_exit>

  0000007c <__bad_interrupt>:
    7c:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

  00000080 <_binary_blinks_bin_start>:
    80:	7a e0       	ldi	r23, 0x0A	; 10
    82:	87 0f       	add	r24, r23
    84:	11 24       	eor	r1, r1
    86:	99 27       	eor	r25, r25
    88:	08 95       	ret

  0000008a <main>:
    8a:	80 e0       	ldi	r24, 0x00	; 0
    8c:	0e 94 40 00 	call	0x80	; 0x80 <_binary_blinks_bin_start>
    90:	25 9a       	sbi	0x04, 5	; 4
    92:	2d 9a       	sbi	0x05, 5	; 5


Some parts of the disassembly were ommited so we can focus on what is important. What we have to note here is where is our assembly code, which in this case is at address ``0x0080``. Looking at our ``main()`` function we can see the ``call 0x80`` instruction, this is exactly the call to our assembly routine.

At this point all we need to do is convert the ELF back to HEX and flash it to our micro controller.

.. code-block:: shell-session

  $ avr-objcopy -I elf32-avr -O ihex -j .text -j .data main.elf main.hex


Indeed, this is a faily simplistic example and for sure does not represent a real situation with a real legacy assembly project that needs to be translated to C. So let's take a look at a more complex exmaple that make use of other instructions like ``jmp, call, rjmp``.

Example of a code that uses jmp
===============================

Let's do the same procedure but now using an assembly code that uses the ``jmp`` instruction.

.. code-block:: asm

  .org 0x0000

  _blinks:
    jmp _add

  _add:
    clr r1
    clr r25
    ldi r23, 0xa
    add r24, r23
    ret 

The code is basically the same, we just forced a ``jmp`` to illustrate out point. Ater compiling with ``AVRASM2`` and converting to ELF we have the following:

.. code-block:: objdump

  Disassembly of section .text:

  00000000 < _binary_blinks_bin_start>:
     0:	0c 94 02 00 	jmp	0x4	; 0x4 < _binary_blinks_bin_start+0x4>
     4:	11 24       	eor	r1, r1
     6:	99 27       	eor	r25, r25
     8:	7a e0       	ldi	r23, 0x0A	; 10
     a:	87 0f       	add	r24, r23
     c:	08 95       	ret

Looking at this assembly everythink looks right. Our code starts at ``0x0000`` and the ``jmp`` is going to address ``0x0004``, which is where our ``_add`` routine starts. We know this because the ``clr r1, r1`` is translated to ``eor r1, r1``. Now it's time to link all this to our C code. Let's take a look at the final assembly:

.. code-block:: objdump

  Disassembly of section .text:

  00000000 <__vectors>:
     0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
     4:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
     8:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>

  00000068 <__ctors_end>:
    68:	11 24       	eor	r1, r1
    6a:	1f be       	out	0x3f, r1	; 63
    6c:	cf ef       	ldi	r28, 0xFF	; 255
    6e:	d8 e0       	ldi	r29, 0x08	; 8
    70:	de bf       	out	0x3e, r29	; 62
    72:	cd bf       	out	0x3d, r28	; 61
    74:	0e 94 47 00 	call	0x8e	; 0x8e <main>
    78:	0c 94 6f 00 	jmp	0xde	; 0xde <_exit>

  00000080 <_binary_blinks_bin_start>:
    80:	0c 94 02 00 	jmp	0x4	; 0x4 <__zero_reg__+0x3>
    84:	11 24       	eor	r1, r1
    86:	99 27       	eor	r25, r25
    88:	7a e0       	ldi	r23, 0x0A	; 10
    8a:	87 0f       	add	r24, r23
    8c:	08 95       	ret

  0000008e <main>:
    8e:	80 e0       	ldi	r24, 0x00	; 0
    90:	0e 94 40 00 	call	0x80	; 0x80 < _binary_blinks_bin_start>
    94:	25 9a       	sbi	0x04, 5	; 4

Looking at our ``main()`` routine we can see that the call is correctly made to address ``0x0080``, but when we look at our assembly rotine, at ``0x0080``, we see that the address to which ``jmp`` is going is still ``0x4`` which is clearly wrong. This happens because the assembly was compiled without knowing that it would be linked to another code later, thus needing to have its addresses adjusted.

The correct address should be ``0x0084``. We need to find a way to adjust these addresses to they are correct in the end. A hacky way of doing this is to "shift" our entire code by ``0x0080``. After all, we know that our assembly code will be located at ``0x0080`` in the final binary (we saw this in the ELF disassembly). Changing the ``.org 0x0000`` to ``.org 0x0080`` produces this assembly:

.. code-block:: objdump

  00000080 <_binary_blinks_bin_start>:
    80:	0c 94 82 00 	jmp	0x104	; 0x104 <_etext+0x22>
    84:	11 24       	eor	r1, r1
    86:	99 27       	eor	r25, r25
    88:	7a e0       	ldi	r23, 0x0A	; 10
    8a:	87 0f       	add	r24, r23
    8c:	08 95       	ret

The final address is still wrong. But let's take a closer look on how our ``jmp`` instruction was encoded.

.. code-block:: objdump


    80:	0c 94 82 00 	jmp	0x104	; 0x104 <_etext+0x22>

What we have here is the opcode of the instruction ``0c 94`` and the address to which it should jump ``82 00``. When we compile our code with ``AVRASM2`` we can generate an additional map file that has all symbols and their final addresses (``-m`` option). Looking at this file we have:

.. code-block:: shell-session

  CSEG _blinks      00000080
  CSEG _add         00000082

This tells us that our ``_add`` is at address ``0082`` which is the same address that we see in our encoded ``jmp`` instruction (``0c 94 82 00``), they are just represented in a different way [#]_.

Ou routine that was originally at address ``0x0082`` has a jump to ``0x104``. But ``0x104`` is exactly two times ``0x0082`` so let's change ``.org 0x0080`` to ``.org 0x0040`` and see what happens.

.. code-block:: objdump

  00000080 <_binary_blinks_bin_start>:
    80:	0c 94 42 00 	jmp	0x84	; 0x84 <_binary_blinks_bin_start+0x4>
    84:	11 24       	eor	r1, r1
    86:	99 27       	eor	r25, r25
    88:	7a e0       	ldi	r23, 0x0A	; 10
    8a:	87 0f       	add	r24, r23
    8c:	08 95       	ret

Now we have the ``jmp`` instruction going to the right address! I don't know exactly why this happens but it seems to work. Works also with a much more complex assembly code that uses all instructions at the same time (``jmp``, ``rjmp``, ``call``):

.. code-block:: asm

  _blinks:
    rjmp _add
  _ret:
    ret
   
  _add:
    call _ldi
  _add1:
    add r24, r23
    call _clear
    rjmp _ret

  _clear:
    clr r1
    clr r25
    ret
    
  _ldi:
    ldi r23, 0x5
    jmp _add1 

Final ELF desassembly:

.. code-block:: objdump

  00000080 <_binary_blinks_bin_start>:
    80:	01 c0       	rjmp	.+2      	; 0x84 <_binary_blinks_bin_start+0x4>
    82:	08 95       	ret
    84:	0e 94 4b 00 	call	0x96	; 0x96 <__binary_blinks_bin_start+0x16>
    88:	87 0f       	add	r24, r23
    8a:	0e 94 48 00 	call	0x90	; 0x90 <__binary_blinks_bin_start+0x10>
    8e:	f9 cf       	rjmp	.-14     	; 0x82 <__binary_blinks_bin_start+0x2>
    90:	11 24       	eor	r1, r1
    92:	99 27       	eor	r25, r25
    94:	08 95       	ret
    96:	75 e0       	ldi	r23, 0x05	; 5
    98:	0c 94 44 00 	jmp	0x88	; 0x88 <__binary_blinks_bin_start+0x8>



Conclusions
===========

We were able in this post to take an HEX, convert it to ELF and call an assembly routine inside this binary. But this is just the beginning, we have still a long path ahead until we can take a complex assembly project (10K+ LOC) and mix with C.

When we mix C and Assembly code there are rules about register usage that we need to follow. These rules are described in this Atmel document [#]_. Before you try to reproduce what we did in this post ensure that all register usage complies with those rules or your assembly code may simply not work.

Future Work
===========

We still have a lot of research to do and some more hypothesis to confirm, but this is the subject for future posts. This includes:

* How to insert symbols in the symbol table. This would give us the possibility to call an assembly routine that is "in the middle" of the code;
* How symbol relocation works. When we compare the ELF generated in a C+Assembly project done with ``avr-gcc`` we see that the original assembly symbols (labels) are added to a special section of the ELF called relocatin table. Knowing how to manipulate this table can ease the usage of assembly code and we may even get rid of our ``.org`` instruction hack;
* Find out how to do the calling in the other direction, that is, call a C function from an assembly routine. What e did here was only C code calling assembly code.

Thank you very much for the reading and stay tuned about the future post on this same subject. There's still a lot to do.

Next post: `Converting Intel Hex to ELF32-avr and creating the symbol and relocation tables <{filename}convertendo-ihex-para-elf-preservando-as-labels-originais-como-simbolos.rst>`_.


.. [#] `Intel Hex Format <http://en.wikipedia.org/wiki/Intel_HEX>`_
.. [#] `Port Registers - Arduino.cc <http://www.arduino.cc/en/Reference/PortManipulation>`_
.. [#] `Endianness <http://en.wikipedia.org/wiki/Endianness>`_
.. [#] `Mixing Assembly and C with AVRGCC - Atmel Corporation <http://www.atmel.com/images/doc42055.pdf>`_
