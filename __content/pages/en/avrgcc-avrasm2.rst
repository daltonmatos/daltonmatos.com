:title: Mixing avrasm2 code with avr-gcc code: A proof of concept.
:author: Dalton Barreto
:lang: en
:translation: true
:slug: avrgcc-avrasm2


Below you can find a research I did where I show in practice how to mix code from a legacy Assembly project (written with avrasm2 that generates only an Intel Hex file) with a Modern C project (written with avr-gcc) that can use more advanced concepts such as code relocation, symbol tables, link-editing and more.

The research is split into four blog posts where I advance gradually solving the problems I encountered along the way. All codes shown in the posts have been tested in practice and are functional. The tests were done on an Arduino Nano (ATMega328P) and on a `KK2 flight controller board <http://www.hobbyking.com/hobbyking/store/__54299__Hobbyking_KK2_1_5_Multi_rotor_LCD_Flight_Control_Board_With_6050MPU_And_Atmel_644PA.html>`_ (ATMega644p).

Below are links and a brief explanation of the four posts:

1. `Calling legacy Assembly code (AVRASM2) from modern C code (avr-gcc) <{filename}/articles/en/chamando-codigo-assembly-legado-avrasm2-a-partir-de-um-codigo-novo-em-c-avr-gcc.rst>`_

The first post shows that you can call assembly code just by changing the address of symbols in the elf file generated by ``avr-gcc`` (from ``main.c``). This approach stops working as soon as we start writing more complex Assembly code, for example, using branch instructions (``jmp, rjmp, call, etc``).

2. `Converting Intel Hex to ELF32-avr and creating the symbol and relocation tables <{filename}/articles/en/convertendo-ihex-para-elf-preservando-as-labels-originais-como-simbolos.rst>`_

The second post addresses the issue of the previous post regarding the use of branch instructions in assembly code. In this post we manipulate the elf's relocation table we generate from our assembly code, thereby making the ``avr-gcc`` change the addresses of branch instructions, generating a proper final binary.

3. `Calling modern C code (avr-gcc) from legacy Assembly (avrasm2) <{filename}/articles/en/chamando-codigo-novo-em-c-avr-gcc-a-partir-de-um-codigo-assembly-legado-avrasm2.rst>`_

The third post evolves the technique used in the previous post. In this post we add the concept of external symbol (we had already used internal symbols before). This means we can add an external symbol to the elf that was generated from the assembly code, thus being able to declare routines in assembly that will have their implementations replaced during link-editing by implementations in C.

4. `Dealing with data stored in the flash, EEPROM and SRAM memories <{filename}/articles/en/lidando-com-dados-inicializados-gravados-na-memoria-flash-eeprom-sram.rst>`_

The fourth and final post handles constants that are stored in the chip code memory. Deals specifically with AVR ``LPM`` and ``SPM`` instructions that work in a peculiar way and therefore require address correcting at compile time.


Code used during the research
=============================

Below you can find the link to the repository where there are codes that were used during this research. They are codes that I wrote as proof of concept to validate the assumptions made during the research, so do not expect to find anything beautiful. = D

 * https://github.com/daltonmatos/avrgcc-mixed-with-avrasm2


